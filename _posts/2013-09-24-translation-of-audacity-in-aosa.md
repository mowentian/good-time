---
layout: translation
title: "Translation of Audacity in AOSA"
date: 2013-09-24
categories: translation
---

# Audacity

Audacity 是一个流行的声音录制和音频编辑器。它在提供了复杂有效功能的同时，也提供了很强的易用性。尽管大部分用户在 Windows 上使用它，但是这份相同的代码也在Linux 上、mac上编译运行。

Dominic Mazzoni 在1999年的时候写了Audacity的最初版本，当时他真正CMU读研究生。当时，编写 Audacity 的目的，是 Dominic 想创展一个能够开发与调试音频处理算法的平台。渐渐地，该软件因为它自身的优势在各个方向都发展起来。但 Audacity 被作为开源软件发布的时候，它便吸引了众多开发者。一个小型的，逐步变化着的由热衷者构成的团队通过其多年的工作，对这个软件进行了开发完善，包括修改、维护、测试、更新、书写文档、帮助用户并且将 Audacity 的接口翻译成其他的语言。

有一个目标在Audacity 的用户界面（UI）上显而易见的：用户能够在没有指南的情况下面直接开始使用该软件，并且逐渐发现该软件的功能。这一原则是Audacity 的用户界面之所以设计成这个样子的最重要因素。而对于一个由众多开发者参与的项目来说，这一原则的统一，将比它说表现得更为重要。

如果Audacity的架构，有一个类似的指导性原则以及一种相似的发现能力，将是一件很好的事情。最为类似的一个原则就是“努力并且保持一致”。当添加一段新的代码的时候，开发者努力遵守了附近代码的风格以及约定。所以，在实际开发中，Audacity的代码中即有组织良好的代码，也有结构还有待提升的代码。因此，与其将这个结构比喻成一个建筑，倒不如称之为一个小城市：其中既有一些让你印象深刻的高楼，也有一些破烂的小木棚。

## Audacity的结构

Audacity 在几个库上进行了分层。尽管大部分在 Audacitu 代码中的新的代码并不需要对这些库中的实现细节以及运行细节有详细的了解，对这些库的 API 的熟悉，以及知道它们是做什么用的仍然是一件重要的事情。其中最为重要的两个库是 PortAudio，用于提供一个底层的夸平台的音频接口，以及 wxWidgets，用于提供跨平台 的 GUI 模块。

在阅读 Audacity 的时候，能够帮助你了解到，在系统中，其实只有少部分的代码是最基本、核心的。库贡献了很大部分的可选功能——尽管对于那些使用这些功能的用户来说这些功能并不是“可选”的。比如说，Audacity 不仅仅有自己内建的音频效果，它也支持了 LADSPA（Linux Audio Developer's Simple Plugin API）作为动态载入的音效插件。而在其中的 VAMPAPI 也做了相同的分析音频的事情。如果没有这些 API，那么Audacity  会变得没有那么功能繁多，但是，Audacity 并不完全依赖这些功能。

另外一些 Audacity 所使用的可选库是 libFLAC、libogg 以及 libvorbis。这款库提供了多样地音频的压缩格式。Mp3 格式由动态加载的 LAME 或者 FFmpeg 库所提供。因为许可证的限制，这些流行的音频压缩格式并不是作为内建的库而存在。

许可证也是决定 了 Audacity 的库与结构的一个重要因素。比如说，对 VST 的支持并不是内建的，因为 VST 具有 许可证的限制。而且，Audacity 也更加倾向于使用更快更高效的 FFTW。傅立叶变化代码是 Audacity 中的内建代码，但是仅仅将其作为一个可选项，并且在用户并不喜欢现有的略微慢一点点的二进制文件而选择自己 编译 Audacity 源码的时候提供。就像 Audacity 引入了各种插件一样，在使用 FFTW 与否这一问题上面，也有一定的争论。因为 FFTW 的作者不希望他们的代码能够作为其他软件的服务而被获取，所以使用插件的架构设计也让我们在这点上面有了一个能够担负的了的协定（应该指软件没有因为侵犯 FFTW 的许可而被搞挂掉）。这一设计，让我们在预建的可执行文件中能够只用 LADSPA 插件，同时，也不再依赖 FFTW。

现在的架构也成型于考虑如何使用团队中各自的紧张而缺乏的时间。作为一个小的开发团队，我们并没有很多资源来做一些，比如一些类似 Firefox 团队或者 Thunderbird 团队一样的深层次的安全漏洞分析。但是 ，我们也不想让用户给 Audacity 开启一个防火墙例外。所以，我们在 Audacity 上不实现任何和 TCP/IP 有关的接口。而这一决定，减少了很多安全隐患。同时，对有限资源的意识，也引导着我们做出更好的设计。它帮助我们学会削减那些会花费大量开发时间的（不重要的）需求，而让我们将注意力集中在核心上。

同样的，出于节约开发者时间的目的，Audacity 也实现了对脚本语言的支持。我们想要让它支持脚本语言，但是我们用于支持的脚本语言并不需要被使用在 Audacity 中使用（或者说有该语言写的接口）。将所有的脚本语言都编译进 Audacity 并不能满足用户对此的需求。所以我们另辟蹊径，实现了一个单独运行脚本的模块，并排使用管道（a pipe）将其连接起来，这在之后会有所提到。

上图（Fugrue 2.1）展示了Audacity 中的一些层和模块。这个图展示了 wxWidgets 中的三个重要的类，每个类在 Audcacity 中都有其相应的映射。另外，我们也在这些底层库之上构建了抽象层。比如说，BlockFile 系统便是一个由 wxWidgets 中的 wxFiles 的一个映射。在某些平台上面，这一功能能够将 BlockFiles、ShuttleGUI 以及命令行控制模块分离成各自相分离的库。这样，将让这些库变得更为通用。

在这个图下面一些的一条狭窄的带，是“Platform Specific Implementation Layers”(平台细节实现层)。因为 wxWidgets 和 PortAudio 都是系统的抽象层，所以这些代码将会根据不同的系统来进行特定的实现。

在这里“Other Supporting Libraries”（其他支持的库），包括了大量的库的集合。有趣地是，这些库中相当的一部分是动态加载库，这些动态加载库将并不会知道有wxWidgets 的存在。

在 Windows 的平台上面，我们曾经使用将 wxWidgets 和 Audacity 成型的代码编译成一个集成的可执行文件。直到 2008 年，才改为使用 wxWidgets 的模块结构（一个分开的 dll）。这样 Audacity 能够在运行的时候的动态加载那些直接使用 wxWidgets 功能的附加可选 dll。在途中，那些在虚线上面的插件能够使用 wxWidgets。

在 wxWidgets 中使用dll（动态库）也有其缺点。Audacity 的发行版现在变得越来越大了，有部分原因就是其中包含了很多提供了用户不需要功能的 dll，这些是需要优化掉的地方。当然，这一选择带来的好处是相当大的。我们认为，使用各种模块，带来的好处正如其给apache带来的一样。正如我们所见，各种模块的分离，使得 apache 的核心变得相当稳定，同时也可以在上面引入灵活的实验性模块、特殊功能模块、以及各种新的模块。模块化给我们省去了很多的工作，因为当我们想要给这个项目一个新的方向的时候，这样做，使得我们不需要重新开一个新的项目（而只需要引入、加载新的模块便可以了）。我们认为，模块化对我们来说将是一个相当重要的架构改变。虽然尚未真正地体会到它所带来的那些好处，不过我们已经能够对此有所预见了。而将 wxWidgets 模块分离出来，也仅仅是我们要将系统模块化的第一步。

像 Audaccity 这样的软件，它的软件结构并不是一开始便设计好的。而是一种随着开发的进行而出现的东西。总的来说，现在的架构在我们目前的开发上能够很好的工作。但是我们依然发现，如果我们要想添加一些设计到很多代码的新功能，这将是一个和现有架构的巨大斗争 。比如说，Audacity 现在能够通过一个特殊地封装过程良好地控制双声道和单声道音频。但是如果你想要让 Audacity 支持环绕音，你将需要修改其中的很多类。

### 由立体声得到的启发：GetLink 案例

Audacity 从来都没有一个抽象层用于处理多个数量的频道。它使用了一个对音乐频道的链接。在这里有一个 GetLink 函数，如果输入的是一个双声道，那么将返回一个音频的对，如果输入的是一个单声道，那么便返回 NULL。这段使用 GetLink 的代码在过去，最开始写来用作单声道的实现，之后又使用“GetLink()!=NULL”这个判断来处理双声道的情况。我并不是非常确定 Audacity 中是这样思想的，但我怀疑是这样。这里没有一个循环来使用 GetLink 来处理所有 的声音频道并且返回一个列表。拖曳、混音、读取、写入等等相关涉及到双声道的代码，都包含了这个判断（GetLink()!=NULL），而不是实现一段通用的处理 n 个频道的代码（n = 1 or 2）。为了实现这一通用代码，你必须修改对 GetLink() 的将近100多次调用，并且涉及了至少26个文件。

搜索 GetLink 并且进行修改并不是一件困难的事情，比最开始的时候听起来要简单的多。这个案例的重点并不是一个引起了修改困难的结构。但是，这个案例说明了原来的架构上，引入一段简简单单的改动将会涉及到一大段代码（就像上面说的）。

因为有了上述的前车之鉴，我们将 GetLink 方法便成了私有方法，并且提供了一个迭代器来循环访问一个音频中的所有声道。这个改动，减少了大量处理双声道的代码，同时，这个代码中对于声道的列表实现，也让 Audacity 支持了其他多种的声道。

## wxWidgets GUI 库

对于 Audacity 用户界面开发人员来说，最重要的那个库就是 wxWidgets GUI 库了。这个库提供了一些类似按钮、侧边栏、检查框、视图以及对话框等等的东西。同时，它也提供了最为明显的跨平台的功能。这个库有它自己的string类——wxString，它有跨平台的对于线程、文件系统、字体的跨平台抽象层，以及语言转换的机制。我们推荐刚刚开始 Audacity 的人民网你下载 wxWidgets 并且编译与体验一下其中的一些样例。wxWidgets 是一个使用操作系统的 GUI 对象的相对较薄的那一层。

为了构建复杂的对话框，wxWidgts 不仅仅提供了个别的 widget 元件，也提供了控制这些元件大小、位置的控制器（sizer）。这比直接提供绝对的、固定位置的图形元件要好很多。如果某个元件被用户重新配置了，比如说，定义了一个不同的字体，这个元件便能够被控制器（sizer）更新大小与位置，使得在界面上面看上去非常的自然 。控制器在跨平台的应用上面尤其重要，如果没有这些，我们将在不同平台上面都要对对话框的布局进行控制。

一般而言，这些对话框的设计在能够被程序读取的资源文件里面的。但是在 Audacity 中，我们将其编译到了代码里面，作为一系列的对wxWidgets 函数的调用。这样做提供了最大的灵活性：就是说，那些拥有特定内容与行为的对话框将在程序层面的代码中被决定。

你可以在第一时间找到 Audacity 用于初始化 GUI 的代码，因为创建一个 GUI 被非常清晰的组织在了一个对话框创建工具里。这些工具能够帮助我们获取一个基础的设计。接下来，这个基础的设计能够被使用来添加新的功能，而这样做的结果，你能够发现，在 Audacity 中有很多新的对话框，便是通过拷贝、修改那些现有的、已经被破解的对话框代码而来。

在多年使用这样的开发方式之后，我们发现在大部分 Audacity 的源代码中，特别是那些用于提供用户配置项的对话框，存在了大量的代码冗余。这些代码，虽然提供了很简单的功能，但是却变得相当困难来跟踪、追查。其中的部分问题，就是那些我们组合这些控制器的序列是相当随机的：小的元件被组合成了大的元件，并且最终被组成了最后的对话框，但是这些用于组成这些元件的代码，并不是按照它们在屏幕上展示出来的先后顺序位置来组织的（虽然的确并不需要这样）。而且这些代码也还有大量地冗余与重复。这里有和 GUI 相关的从硬盘中的配置项传递配置到中间变量的代码，这里有从中间变量传递参数到展示出来的 GUI 的代码，这里有从展示了的 GUI 传递参数到中间变量的代码，这里又有从中间变量中将配置存储回硬盘的代码。这 Audacity 中，有很多被称作是“//this is a mess（这是一个烂摊子）”的注释，所以，我们要花一些时间为此做些什么了。

## ShuttleGui 层

对于上述代码问题的解决方案，是一个新的类，ShuttleGui。这个类大量减少了用于指定一个对话框的代码，同时也提高了代码的可读性。ShuttleGui 是一个在 wxWidget 库和 Audacity 之间的特别层。它所做的工作，就是在这两层之间传递信息。下面就是一个使用例子：

{% highlight c %}
ShuttleGui S;
// GUI Structure
S.StartStatic("Some Title",…);
{
    S.AddButton("Some Button",…);
    S.TieCheckbox("Some Checkbox",…);
}
S.EndStatic();
{% endhighlight %}

这段代码在对话框中定义了一个静态框，在这个框中包含了一个按钮和一个检查框。在代码和对话框中的通信变得清晰。StartStatic 和 EndStatic 是一对调用。另外，也有一些相似的 StartSomething/EndSomething 函数对，用于控制其他的对话框中的布局。在上述代码中，花括号和缩进其实并不需要（？），但是我们依然将这些引入进来，是的我们的代码能够将结构和相关的函数调用对变得更加地清晰。这样做，对于大型例子的可读性上帮助巨大。

源代码不仅仅是创建了对话框。在“//GUI Structure” 注释之后的代码同样能被用于将用户定义的数据展示出来并且保存回去。在之前，我们耗费了很多重复代码来实现这一的功能。而现在，这些代码仅仅被书写了一次，并且被 ShuttleGui 类隐藏了起来。

在 Audacity 中也有其他基于 ShuttleGui 的扩展。Audacity 也有它自身的用于管理工具栏的类。那为什么不用 wxWidget 自带的类呢？这是一个历史原因：Audacity 的工具栏比 wxWidget 提供工具栏类之前便已经写好了。

## 仪表盘（The TrackPanel）

在 Audacity 中，主要用于展示音频波形的面板，被称作是仪表盘（TrackPanel）。这是由 Audacity 绘制的一个自定义的面板。该面板由多种小型组件组成，比如那些显示以音轨信息的小面板、一个时间的标尺、振幅的标尺、显示了波形、文字、范围的音轨等等。在面板上的音轨能够通过抓取实现大小调整、移动等操作。包含有文本标签的音轨将使用我们重载的一个可编辑的文本框，而不是内建的文本框。你可能会认为这些面板、标尺都是 wxWidgets 的逐渐 ，但实际上，它们不是。

上图是一个 Audacity 用户界面的截图。所有在上面展示的模块都是由 Audacity 定制过的。虽然 wxWidgets 中也有 TrackPanel 的内建模块，Audacity 的代码，而不是 wxWidgets 的，对此进行了布局和重绘。

将这些模块组织起来的方式，让这个 TrackPanel 变得相当的可怕（这里指的是代码，而用户体验倒是良好）。GUI 的代码，和程序制定的代码都混合在了一起，而不是清晰地分开。在一个良好的设计中，只有程序定义层的代码才需要了解左声道、右声道面板、分贝、静音、以及单声道。而 GUI 的原件应该是程序所不可知的，并且也能够被废音频的软件所重用。就算是在 TrackPanel 中纯粹用于实现GUI部分的代码也根据程序所需要使用的用例而实现了固定的位置和大小，而没有能够足够抽象。如果在实现中，能够像 wxWidgets 中实现的那样，使用一些特殊的 GUI 的通用原件，而使用一些控制器（sizer）来对其布局大小等等进行控制，那样会变得更加的优雅、简洁以及一致。

为了实现上述的灵活的 TrackPanel，我们需要一个新的控制器（sizer）用于对tracks，或者说，所有的组件，进行移动、调整大小等。因为 wxWidgets 目前并不那么灵活，所以我们不得在其他的地方使用这个控制器。我们将这个使用在了工具栏中，用于控制按钮。这样，这些按钮的位置能够通过拖拉进行重新定义了。

一些探索性的工作被用作来创造并且使用这样的控制器，但这并不够。一些实验使得组件完全成熟的 wxWidgets 运行是发生了问题：这样做使得对插件的控制减弱了，从而在调整大小与移动组件的时候发生了屏闪。我们需要对 wxWidgets  进行更进一步的修改来完成这一无屏闪的刷新，以及将调整大小的逻辑和重绘逻辑中区分开来。

第二个需要担忧的问题是，我们已经知道 wxWidgets 在加载很多插件的时候启动会变得十分缓慢。这很大程度上是 wxWidgets 控制之外的。对于每一个 wxWidget、按钮以及文字框都将使用一份视窗系统的资源。而且每一个都需要对这个资源有一个句柄。对大量句柄的处理消耗了时间。就算有很多控件被隐藏了或者被禁用了，处理起来的速度依然是很慢的。我们希望能够使用很多小控件在我们的音轨之中。

最好的解决方案是使用轻量级的模式、我们自己来绘制轻量的控件，这样就不会有余wxWeight类似的对象来处理视窗系统的资源或者句柄。我们将使用类似 wxWidget 的 sizer 以及类似的模块，并且给这些模块一些类似的 API 而不是直接使用 wxWeight 的类。我们现在正在对已经存在的 TrackPanel 代码进行重构工作，这样它的代码会看起来更加地清晰。如果这是一项简单的工作的话，那我们早就完成了，不过这个工作可并不容易。组织我们现有的特设的方法需要有重大的设计工作与代码工作。而且，“就让这些能运行的复杂代码这么着吧”，也是我们必须要克服的诱惑。

## PortAudio库：录制与播放

PortAudio 提供了 Audacity 跨平台播放与录制音频的能力。如果没有它，Audacity 不能够使用其中的声卡设备。PortAudio 提供了环缓冲区(ring buffers)、播放/录音时的采样率转换、以及提供了在Mac、Linux与Windows上面Audio的接口（隐藏了内部细节）。在PortAudio 中有很多可选的实现文件，用于支持不同平台上的接口。

我从不需要深入地了解 Audacity 并且知道在它内部有什么实现细节。而需要做的，仅仅是要了解我们将如何和 PortAudio 进行交互。Audacity 接收了来自 PortAudio 的数据包（录制时），也能够向 PortAudio 发送数据包（播放时）。看看具体发送和接收是如何发生的，以及 Audacity 如何将数据从硬盘上进行读写，并且更新到屏幕上是值得的。

在这里，有几个不同的进程在同时工作着。有些进程运行十分频繁，用于传输少量的数据，但是必须能够迅速响应。其他的则运行得并不十分频繁，用于传输大数据块，并且它们的运行时间并不需要十分地准确。在这里，便有不匹配的存在，在这里，使用了缓存（buffer）来进行解决。第二点，在图中可以发现，我们需要和以音频设备、硬盘设备以及屏幕打交道。我们并不是在底层总线层面上对这些硬件进行控制，所以我们实现了对其进行操作的 API。同时，我们也希望每一个进程看起来尽量的类似，比如，我们这些线程都使用了 wxThread。

一个音频的线程石油 PortAudio 代码启动的，并且与音频设备进行交互。这个线程驱动了录音和播放功能。这个线程必须要有应答，不然的话，就会产生丢包。这个在 PortAudio 代码控制下的线程，被称之为“audacityAudioCallback”。该线程，在进行录音的时候，将进来的音频新包添加到一个更大的抓取缓冲区(5s)中。而杂igz播放时，它会从这个 5s 的播放缓冲区中读取一个个小片段。这个 PortAudio 库与wxWidgets 毫不相关，所以其中的线程使用的是 pthread。

第二条线程由 Audacity 中的 AudioIO 类启动。在进行录制的时候，AudioIO 从上面的抓取缓冲区中读取数据，并且将这些数据 追加到 Audacity 的音轨中，这样的话这些音轨便能够用于展示了。另外，如果有足够多的数据被添加了，AudioIO 也会将这些数据保存在硬盘中。同样的，这里也有一条从硬盘中读取硬盘并且播放的线程。其中，“AudioIO::FillBuffers”这是在一个方法里面通过一个 Bool 值来判断是采取录制还是播放功能的核心方法。一个函数能够用于能够处理两个方向是重要的。这样，播放和录音变能够在同时被使用了，你也能够将之前的录音整合进去（...）。在 AudioIO 线程中，我们主要受限于操作系统的硬盘IO。我们可能无法处理那些未知长度的读写请求，因为在 audacityAudioCallback 中，我们需要有一个响应。

在上面两条线程间的交流使用了共享变量。因为我们能够具体控制哪条线程在何时对共享变量进行写操作，所以我们避免了实现复杂的互斥锁。

在播放和录制中，这里有一个附加需求：Audacity 需要同时更新 GUI。这是（代码）耗时最少的关键操作。这个更新操作在 GUI 的主线程中是用一个 20次/s 计时器来完成。这个计时器每次都会调用“TrackPanel::OnTimer”，如果发现了存在用于 GUI 的更新，并完成这个操作。这个 GUI 的主线程使用 wxWidgets 创建的。因此，其他的线程是无法直接更新 GUI 的。使用这个计时器来检测是否有更新，是我们减少了对 GUI 的重绘次数，降低了用于展示用的处理器资源。

将系统划分成了一条音频设备线程、一个缓冲区/硬盘线程以及一个有定时器的GUI线程，用于处理音频的传输是一个好的设计吗？这三个线程均是不同的，而并不是基于一个抽象基类。这一不同，在很大程度上是因为我们所使用的那些库。PortAudio 需要它自己创建一条线程，而 wxWidgets 框架自动创建了一条 GUI 线程。而我们对于 buffer 线程的需求来源于我们需要处理来自于音频线程的大量小数据和硬盘块设备的少量大数据的不匹配。使用这些库带来的好处十分明显。而主要的花费在于我们最终使用了它们提供的抽象层。因此（使用多线程），我们将数据从内存中的一个地方，拷贝到另外一个更为地方。在我之前维护的快速数据转换模块上，我看到了非常有效的不需要开启多个线程而能够同步不同设备间数据，并且处理其速度问题的代码。在它们之间，传递的是数据的指针，而并非是拷贝了数据。但是，我们仅仅能够在拥有更加强大缓冲层设计的库中才能够有这样的实现。因为我们现在使用了上面的库，所以我们不得不使用多线程，以及拷贝内存数据。

## BlockFiles（块文件）

一个 Audacity 需要面对的问题是，需要支持多个小时长度的音频的添加和删除。音频的录制会很容易达到内存上限（如果存在内存中的话）。如果一个音频的录制是在单个硬盘文件中的，那么，如果你需要在音频的的开头插入某段内容，将会硬盘指针移动很长的一个片段。在硬盘中拷贝数据将消耗巨大使得 Audacity 在进行简单操作的时候的性能仍然不够理想。

Audacity 的解决方案是将这些文件划分成多个 BlockFile（块文件），每一个块文件的大小约 1M。这就是 Audacity 需要它自身的格式的原因（有一个 .aup 后缀的主文件）。这个文件是一个 XML 的文件，在该文件中组织了各种块。上述的例子中的改变，也将仅仅影响到其中的一个 block 与这个主 .aup 文件。

块文件需要平衡了两个冲突。我们能够插入和删除音频而不需要担心过度的复制，同时在播放的同时，也保证了我们也能够在每次请求中获取到合理大小的数据块。越小的块，在读取相同大小的数据时，对硬盘的请求越多；越大的块，再进行插入和删除时候，则需要越多的多度复制。

Audacity 的块设备并不会有空余的内部空间，并且在达到限制大小之后，它们便不再增长。为了保证这一情况，当我们进行插入和删除的时候，我们将停止拷贝将更多的数据拷贝进这一个块中。但我们不再需要这个块，我们便将其移除。当删除一个块的时候，仅仅是在引用中将其删除，确定的块依然处于闲置模式，直到用户将其删除，这一操作将支持用户的撤销操作。在这里，我们并不需要对 Audacity BlockFile进行垃圾回收处理，我们的所有操作都是在一个文件之中的。

合并与分割大的数据块就好比是数据管理系统的面包和黄油。在此，我们从 B-tree 转换到了 Google 的 BigTable 用于管理这些平铺的链接列表。

块文件不仅仅是用在Audio上，还被用于缓存一些摘要信息。如果 Audacity 被要求显示一个长达 4 个小时的音频的数据 ，它每次都去重新分析整个文件并且重绘这个屏幕，这是不可接受的。所以，在这里，Audacity 使用了摘要信息来提供在一定时间之内的音频的最大、最小振幅。当用户放大该信息的时候，Audacity 才真正地对这个音频进行分析。如果缩小回去，那么，Audacity 将使用摘要进行显示。

还有一个精致的块文件设计是，这些块并不必须是由 Audacity 所创建的。它们可以由其他音频的文件中的信息给导入进来，比如在 .wav 文件中的时间戳信息。一个用户可以创建一个 Audacity 项目，并且导入一个 .wav 的文件，而 Audacity 将仅仅使用 BlockFile 来存储其摘要信息。这样做能够减少硬盘空间，以及拷贝文件的时间。很不幸的，这是一个坏主意。很多很多的用户，在导入这个wav之后，都会将它给删掉，因为他们认为自己已经创建了一个工程了。但是并不如此，在没有这个源文件的情况下，Audacity 并不能进行工作。所以，现在，在默认配置下，Audacity 现在也会将这些文件导入进去，并且同时生成块文件。

这个 BlockFile 的解决方案在 Windows 系统上们遇到了一个问题，那就是在大量块文件的情况下面，系统将运行地十分缓慢。这是因为在Windows 下面，系统在处理一个文件夹下面的大量小文件的时候性能会变得缓慢，和大量控件导致速度缓慢一样的问题。所以，接下来会有一个新的功能，会使用多个子文件夹来存放文件，每个子文件夹中不会超过100个文件。

这里会有一个问题，那就是 BlockFile 的结构是暴露给最终用户的。我们经常会遇到这样的现象：用户移动了其中的 .aup 文件，但是他们并不清楚，他们需要移动相关的文件夹。如果这个工程文件只有一个文件，并且由 Audicity 来处理内部的空间的话，那就会变得更好。如果要这么做并且使得其性能会变得更好，那么其中主要要做的一个功能便是垃圾回收。一个简单的方法就是，当一个文件的使用量达到某一个百分比的时候，将它的块拷贝到新文件中，而不是对它进行保存。

## 脚本语言

Audacity 有一个实验性质的接口用于支持多种脚本语言。它在命名管道上提供了一个脚本语言的接口。正如其响应一样，使用脚本写的命令以文本的方式输入。就像用户的脚本输入输出能够被在命名管道上面作为文本写入并且作为文本读取（响应），这种方式也能用来驱动Audacity。而音频以及其更高层的数据（非txt）并不需要由 pipe 来进行传输。

这个插件本身对其中传输的脚本内容并不知情，它只负责进行传送。这个插件接口（或者说，最基本的扩展点）被脚本插件用于接入Audacity系统并且使用文本方式传输Audacity的命令。所以这个插件很小，之包含了pipe的代码。

很不幸地，一个 pipe 中会有相关的TCP/IP的连接，并且会引入安全问题——这个问题，在前文中我们提到了将不再 Audacity 中引入链接。为了解决这个风险，这个插件是一个可选的动态库。你在确认使用它的时候，必须要好好地考虑安全的问题。

在这个脚本功能启动开发的时候，一个在我们需求页的请求硬卧了我们的注意，就是，我们可以考虑使用 KDE 下的 D-Bus 标准来提供一个 使用 TCP/IP 的进程间的通信机制。虽然我们已经开始了另外一个不同的路由方式，但是这个建议依然有效，并且我们最终支持 了 D-Bus。

### 脚本语言来源

脚本语言的需求来源于一个 Audacity 的爱好者的特殊需求。这些功能，整合在一起叫做 CleanSpeech，提供了一个 mp3 的转换器。而 CleanSpeech 添加了新的一些新的效果，比如说：删除静音——该功能删除了大段音频中的静音，以及对其中的降噪处理、标准化、以及批量录音文件 mp3 的转换。我们想要引入其中的一些卓越的功能。但是它实现的方式对于 Audacity 来说太过特别了。将其代码引入到主流的Audacity 中来需要写一个足够灵活的序列，而并非是一个固定的序列。这个灵活的序列将会遍历定义的命令表，同时一个 Shuttle 的类将根据用户配置来存储其中的参数为文本。这一功能被称作是 batch chains（批量链）。处于谨慎，我们并没有将这些东西进行了更进一步的简化、抽象，来避免我们不得不维护一个新的语言。

现在回顾起来，避免一个分支还是一件值得做的事情。现在仍然存在着一个 CleanSpeech 的模块用于修改配置。它能够及精简用户界面，删除高级功能 。有些用户，特别是一些在学校中的业余用户，会需要一个简单的 Audicity 版本。但是，问题是不同的用户需要的功能是不同的。于是我们随后实现了一个简单的黑客的手段利用翻译机制来实现这个问题。当在菜单栏中的项目由一个“#”来开头的时候，这个项目将不会在菜单中显示出来。通过这种方式，那些希望在菜单中减少一些功能选项的用户能够自己做出选择，而不需要经过编译。这一方式，提供了更多的通用性以及更少的侵略性 。并不像 CleanSpeech 那样在 Audacity 中添加了一系列的 mCleanspeech 的标志。（我们将之后将其完全移除）。

CleanSpeecch 的工作，给了我们的批量处理链以及删除空白片段的功能。这些都是核心开发小组之外的成员所带来的。同时，也让 Audacity 开始支持更多通用的插件的进程。

## 实时效果

Audacity 并没有实时音效，比如说在音频播放的同时添加效果。在 Audacity 中，你必须要确认这一操作，并且等待音频的编码完成。实时效果能够在音频被程序后台进行处理的时候便在前台被用户所体会到。

在这里，我们的一个问题是，这样处理，在性能好的机器上面，看上去是一个实时处理，而在性能较差的机器上面，会变得非常的慢。Audacity 在很多类型的机器上面运行。所以，我们想要一个优雅的后备方案。在运行缓慢的机器上面，我们依然会请求用户在一整个音频上面确认这个效果，并且在这个音频中间左右的部分进行转换提供试听，因为我们知道转换所有的音频将消耗比较大的时间。而在一个更为缓慢而不能进行实时渲染效果的机器上面，我们将等待所有的效果都回放完成之后在进行处理。为了实现这一效果，我们移除了对音频效果的在用户界面上的区块限制，并且，这一转码是从整个音频的左边到右边进行的。


## 总结
在之前的章节中展示了一个好的架构设计能够有利于这个软件的发展，但是一个糟糕的设计则会阻碍其发展。

* 来自于第三方的库，如 PortAudia、WxWidget，给 Audacity 提供了极大的益处。它们提供了我们系统的基石，并且解决了很多不同系统平台的差异。但是其中有一个我们必须要面对的问题，因为用这些库，我们在选择抽象层上的灵活性并不高。另外，我们在播放、录制上的代码也并不好，为了实现这个，我们不得不处理三个不同的线程。而且这些代码也需要拷贝很多数据（因为我们无法掌握其抽象层）；
* wxWidgets 提供给我们的 API 让（诱惑了）我们写了一些冗余的、难以维护的代码。而我们解决方案，是在 wxWidgets 上添加了一层抽象层用于使我们的代码更为简洁。
* 在 Audacity 的 TrackPanel 上，我们希望能够让 Audacity 吸收进现有的已经完成的那些控件来获取功能。因此我们开放了可定制的系统。我们使用了一个清晰的具有控件和控制器（sizer）以及逻辑清晰分明的程序来得到一个清晰的 TrackPanel
* 架构上的决定比一个新功能更加宽广。同时，什么功能不应该在这个程序中的决定也同样重要。它能够让你有清晰、安全的代码。同时，在使用类似 Perl 的脚本语言上面，也获益匪浅，这让我们省去了维护自己一套语言的工作。架构上的决定同样有未来的发展计划而决定。目前模块化的雏形系统也能够让未来的一些实验性工作变得更加安全。一个新功能地载入，很大程度上希望这是一个渐进式的过程。

你看到得觉多，你就能够越明显地察觉到，Audacity 是一个社区工作的成果。这个社区比那些直接对这个项目的贡献者要大的多。